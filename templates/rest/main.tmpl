{{define "EVREST"}}
package {{.Package}}
import(
    {{imports .Imports}}
)

var VERSION = "{{.Version}}"

var flags *flag.FlagSet
var separator string = "----------------------------------------"
var command string = ""
{{commandFlagsVars .Commands}}
{{if .USE_EVSCHEDULE}}
var wg sync.WaitGroup
{{end}}

func {{.UsageFunc}}(){
	fmt.Println(`{{commandUsage .Commands .}}`)
}

{{template "EVHttpHandler" .}}
{{template "EVRestHttpHandler" .}}

func init() {
	if len(os.Args) <= 1 {
		{{.UsageFunc}}()
		fmt.Println(separator)
		os.Exit(2)
	}
	command = os.Args[1]
	flags = flag.NewFlagSet(command, flag.ExitOnError)
	{{commandFlags .Commands}}
	flags.Usage = {{.UsageFunc}}
	{{if .USE_PROMETHEUS}}
	PromInit()
	{{end}}
}

func main(){
    flags.Parse(os.Args[2:])
	if debug {
		eve.DEBUG = true
	}

	if address == "" {
		address = "{{.DefaultAddress}}"
	}

	ro := NewRestHttpHandler()
	r := mux.NewRouter()
	s := r.PathPrefix("{{.ROUTE_PATH_PREFIX}}").Subrouter()
	s.Handle("/", ro){{range $idx, $url := .URLS}}
	s.Handle("{{$url}}", ro){{end}}
	r.Handle("/", NewHttpHandler())
	http.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir(evwebroot))))
	http.Handle("/", r)

	switch command {

	case "help":
		if hhttp != "" {
			fmt.Println("running http service at", hhttp)
			fmt.Println("help is now available at ::", "http://" + hhttp + "{{.ROUTE_PATH_PREFIX}}help")
			log.Fatal(http.ListenAndServe(hhttp, nil))
		} else {
			{{.UsageFunc}}()
			fmt.Println(separator)
			os.Exit(2)
		}

	case "http":
		fmt.Println("running http service at", address)
		fmt.Println("root assets are served from webroot", webroot)
		fmt.Println("service specific assets are served from evwebroot", evwebroot)
		{{if .USE_EVSCHEDULE}}
		wg.Add(1)
		go func(address string, wg *sync.WaitGroup) {
			defer wg.Done()
			log.Fatal(http.ListenAndServe(address, nil))
		}(address, &wg)
		{{else}}
			log.Fatal(http.ListenAndServe(address, nil))
		{{end}}
	case "https":
		fmt.Println("running https service at", address, "with cert", crt, "and key", key)
		fmt.Println("root assets are served from webroot", webroot)
		fmt.Println("service specific assets are served from evwebroot", evwebroot)
		{{if .USE_EVSCHEDULE}}
		wg.Add(1)
		go func(address, crt, key string, wg *sync.WaitGroup) {
			defer wg.Done()
			log.Fatal(http.ListenAndServeTLS(address, crt, key, nil))
		}(address, crt, key, &wg)
		{{else}}
			log.Fatal(http.ListenAndServeTLS(address, crt, key, nil))
		{{end}}
	case "version":
		fmt.Println("version " + VERSION)
		os.Exit(0)

	default:
		fmt.Println(separator)
		fmt.Println("the given command", command, "is not supported now")
		{{.UsageFunc}}()
		fmt.Println(separator)
		os.Exit(2)
	}
	{{if .USE_EVSCHEDULE}}
		wg.Add(1)
		go func(s *Scheduler, wg *sync.WaitGroup) {
			fmt.Println("EVSchedule :: starting scheduling...")
			defer wg.Done()
			time.Sleep(1 * time.Second)
			err := s.Run()
			if err != nil {
				log.Println(err)
			}
		}(EVSchedulerObj, &wg)
		// normally wg.Wait() should be used but in our case we want to
		// shutdown the scheduler so we need to wait for the shutdown quit message
		// on the MainQuitChannel
		qMsg := <-EVSchedulerObj.EVSched.MainQuitChannel
		close(EVSchedulerObj.EVSched.MainQuitChannel)
		log.Println("received main quit channel message::", qMsg)
	{{end}}
}
{{end}}
